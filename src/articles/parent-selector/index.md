---
title: 'Почему у нас нет селектора по родителю'
date: 2011-09-20
author: jonathan-snook
source:
    title: 'Why we don’t have a parent selector'
    url: 'http://snook.ca/archives/html_and_css/css-parent-selectors/'
translators:
    - vadim-makeev
layout: article.njk
tags:
    - article
    - css
preview: 'Относительно регулярно я вижу дискуссии о том, должен ли CSS включать селектор по родителю и, пока я не выяснил, как работает движок браузера, сам строил предположения по этому поводу.'
---

Относительно регулярно я вижу дискуссии о том, должен ли CSS включать селектор по родителю и, пока я не выяснил, как работает движок браузера, сам строил предположения по этому поводу.

Вкратце: _производительность._

## Как работает CSS

В связи с моей работой я делаю много тестов производительности. Для определения «узких мест» мы используем массу приложений. Например, Google Page Speed, который дает рекомендации по улучшению производительности JavaScript и рендеринга. Прежде чем я перейду к рассмотрению этих рекомендаций, нам нужно разобраться как браузеры работают с CSS

## Стиль элемента применяется в момент его создания

Мы часто рассматриваем веб-страницы как полноценные документы, наполненные элементами и содержимым. Между тем, браузеры разработаны так, чтобы обрабатывать документ потоково. Они начинают получать документ с сервера и могут начать его отображать до момента полной загрузки. Каждый узел анализируется и отображается в окне по мере получения.

Взгляните на этот документ:

```html
<body>
    <div id="content">
        <div class="module intro">
            <p>Lorem Ipsum</p>
        </div>
        <div class="module">
            <p>Lorem Ipsum</p>
            <p>Lorem Ipsum</p>
            <p>Lorem Ipsum <span>Test</span></p>
        </div>
    </div>
</body>
```

Браузер начинает сначала и видит элемент `<body>`. В этот момент времени считается, что этот узел не имеет дочерних узлов. Ничего более не рассматривается. Браузер определяет соответствующий ему обобщенный набор стилей и применяет его к элементу. Какой шрифт, цвет, интерлиньяж? После того, как это все будет выяснено, элемент отображается на экране.

Далее браузер видит элемент `<div>` со значением атрибута ID `content`. И снова в этот момент времени браузер считает его пустым. Он не рассматривает другие элементы. Как только браузер рассчитает стиль, элемент отображается на экране. Затем браузер определяет нужно ли перерисовать `<body>` — стал ли элемент шире или выше? Я подозреваю, что там есть масса других проверок, но изменение ширины и высоты — самый распространенный способ повлиять на отображение родительского узла.

Процесс продолжается, пока браузер не достигнет корневого узла документа.

Вот как выглядит визуализация процессов перерисовки в Firefox:

<iframe src="https://www.youtube.com/embed/ZTnIxIA5KGw" allowfullscreen></iframe>

## CSS-селекторы анализируются справа налево

Чтобы определить, применяется ли CSS-правило к определенному элементу, браузер рассматривает селектор справа налево.

Если у вас есть селектор `body div#content p { color: #003366; }`, то, когда каждый элемент появляется на странице, браузер проверяет, является ли он параграфом. Если да, он начинает подниматься вверх по DOM и ищет `<div>` со значением атрибута ID равным `content`. Если он его находит, то продолжает подниматься по DOM пока не найдет `<body>`.

Таким образом, читая селектор справа налево, браузер значительно быстрее может определить применяется ли правило к элементу. Чтобы определить, какой из селекторов обладает большей производительностью, нужно выяснить, как много узлов придется рассмотреть, чтобы определить, можно ли применить правило к элементу.

## Правила

Возвращаясь к Page Speed, давайте рассмотрим [несколько его рекомендаций](http://code.google.com/speed/page-speed/docs/rendering.html#UseEfficientCSSSelectors):

- Избегайте селектора по потомку: `.content .sidebar`;
- Избегайте селектора по дочернему элементу: `.content > .sidebar` и селектора по следующему элементу: `.content + .sidebar`.

Конечно, селекторы по ID — самые быстрые. Проверить применимость селектора `#content` к рассматриваемому элементу можно очень быстро. Есть у него этот ID или нет? Селекторы по классу практически такие же быстрые, так как нет никаких связанных элементов, которые надо проверять.

Селекторы по потомкам, такие как `.content .sidebar` — более ресурсоемкие, так как, чтобы определить надо ли применять правило к `.sidebar`, браузер должен найти `.content`. Cелектор по дочернему элементу, например, `.content > .sidebar`, лучше селектора по потомку, так как браузер должен проверить только один элемент вместо множества. _(К сожалению, селекторы `+` и `>` не поддерживаются IE6. Так что если его поддержка актуальна для вас, то про них придется забыть — прим. переводчика)._

## Селектор по тегу и универсальный селектор

В рамках рекомендации избегать селекторов по потомку, дочернему или следующему элементам, рекомендуется избегать универсального селектора и селектора по тегу.

Рассмотрим следующий пример:

```css
#content * { color: #039; }
```

Так как в селекторе присутствует ID, то можно подумать, что этот селектор обрабатывается очень быстро. Проблема в том, что браузер обрабатывает селектор справа налево и сперва проверяется универсальный селектор. Для того чтобы браузер мог определить, должен ли цвет текста элемента быть тёмно-синим, надо проверить каждый предок элемента, пока не будет найден предок с атрибутом ID равным `content` или не будет достигнут корень документа.

И это должно быть сделано для каждого элемента на странице.

Теперь, когда мы понимаем, как элемент обрабатывается, как определяется применимость правил к элементу, давайте рассмотрим пример.

## Почему IE долго не поддерживал `:last-child`

Все жаловались: у всех браузеров, кроме IE, есть поддержка `:last-child` (она появилась только в IE9!) Некоторые могли подумать <q>насколько же сложнее сделать `:last-child`, если уже реализован `:first-child`?</q>

Давайте представим, что мы — браузер и мы парсим документ-пример, который я приводил ранее.

```css
.module > p:first-child { color: red; } /* Первое правило */
.module > p:last-child { color: blue; } /* Второе правило */
```

Когда мы рассматриваем внутренности первого `<div>`, мы видим, что там есть параграф. Браузер видит что-то вроде этого:

```html
<div class="module">
    <p>Lorem Ipsum</p>
```

Нужно ли применить первое правило к параграфу? Да, это параграф; да, это первый дочерний узел; и, да, это непосредственный потомок элемента с классом `module`.

Нужно ли применить к этому параграфу второе правило? На данный момент это последний элемент. Но мы могли ещё не загрузить все элементы и не можем быть уверены, что он останется последним.

Вне зависимости от того, как решать эту дилемму, у нас возникает необходимость повторного анализа стилей двух узлов для каждого нового узла, который мы добавляем в DOM. Если я добавлю ещё один параграф следом за первым, мы должны так же повторно перерассчитать стили, которые применяются к предыдущему параграфу.

## Как на самом деле это делает браузер?

Я не мог сказать с абсолютной уверенностью, как браузеры парсят `:last-child`, так что я создал несколько тестов:

- [Статическая HTML-страница](http://testing.snook.ca/css-1.html);
- [Рендеринг с паузами в одну секунду](http://testing.snook.ca/css-1.php).

Первый пример весьма скучен. В любом браузере, включая IE9, всё отображается корректно. Внутри `<div>` первый элемент красный, а последний синий. Но посмотрите на второй пример, и вы увидите интересные отличия в поведении браузеров.

Второй пример приостанавливается перед добавлением каждого параграфа в `<div>`.

В Firefox первый параграф изначально отображается синим. Когда загружается второй параграф, первый становится красным и второй — синим. Когда загружается третий параграф, второй отображается цветом по умолчанию и третий отображается синим. Firefox рассматривает каждый элемент, который был загружен в качестве последнего элемента, пока не будет загружен ещё один.

В Safari, Chrome и Opera мы увидим другой подход. Первый параграф красный. Второй отображается чёрным. Последний параграф отображается чёрным, пока браузер не получит закрывающий тег `</div>`. В этот момент последний параграф становится синим. Эти браузеры не рассматривают элемент как последний, пока не будет закрыт родительский.

В Internet Explorer 9 Beta я нашел интересный баг. В то время, как статическая страница отображается корректно, версия с паузами отрабатывает с любопытным побочным эффектом. Первый параграф синий, второй параграф синий и затем — третий. Когда закрывающий тег `</div>` загружен, предпоследний параграф меняет цвет на чёрный. IE9 пытается обрабатывать селектор как WebKit и Opera, но… м-м… не выходит. Надо бы отправить багрепорт в Microsoft.

## Почему у нас нет селектора по родителю?

Уже дано достаточно пояснений, чтобы можно было вернуться к оригинальному вопросу. Проблема не в том, что у нас не может быть селектора по родителю. Проблема в том, что мы столкнемся с проблемами быстродействия, когда дело дойдет до определения того, какие CSS-правила применимы к данному элементу. Если Google Page Speed не рекомендует использование универсальных селекторов, то можно гарантировать, что селектор по родителю будет первым в списке ресурсоемких селекторов, намного опережая все проблемы с производительностью, которые могут быть вызваны использованием универсального селектора.

Давайте посмотрим почему. Первым делом давайте приведём пример синтаксиса для селектора по родителю.

```css
div.module:has(span) { color: green; }
```

Проблема в том, что мы не можем определить применимость правила до тех пор, либо пока мы не найдем соответствия, либо пока все элементы, дочерние по отношению к родителю данного, не будут загружены. Ввиду этого мы должны оценивать правило и все остальные (в случае наличия специфических особенностей), применяющиеся к элементу, для каждого дочернего элемента, который мы загружаем.

Посмотрите на часть нашего документа:

```html
<div class="module">
    <p>Lorem Ipsum</p>
    <p>Lorem Ipsum</p>
    <p>Lorem Ipsum <span>Test</span></p>
</div>
```

Исходя из того, что мы видим, `.module` будет отображён без использования правила, применяемого селектором по родителю. Когда будет загружен первый элемент `<p>`, нужно повторно оценить применимость селектора по родителю к `<div>`. Нужно сделать это снова для следующего параграфа. И снова, для следующего. Наконец, когда `<span>` загружен, селектор по родителю будет применен к родительскому `<div>`, и элемент нужно будет повторно перерисовать.

И что теперь? Теперь, если изменится любое наследуемое CSS-свойство, каждый потомок должен будет повторно анализироваться и перерисовываться. Ох…

## Почему проблему можно решить с помощью JavaScript?

Это только кажется, что JavaScript решает проблему. В общем случае JavaScript-заплатки _(заплатки — polyfills — части кода, обеспечивающие функциональность, которую должен обеспечивать браузер — прим. переводчика)._ Или регрессивное усовершенствование (или как там вы, молодежь, это сейчас называете) запускаются только один раз, после полной загрузки DOM.

Для того чтобы действительно имитировать поведение CSS, любой скрипт, решающий эту проблему, должен запускаться после отображения каждого элемента на странице, чтобы определить, нужно ли применить нашу «заплатку». Помните CSS-expressions в Internet Explorer? Именно по этой причине они вызывали такие проблемы с производительностью.

## Не невозможно

Появится ли когда-нибудь селектор по родителю? Возможно. То, что я описал, не невозможно. На самом деле — наоборот. Это значит только то, что нам придётся иметь дело с ухудшением производительности из-за использования этого селектора.
